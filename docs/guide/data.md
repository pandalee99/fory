## Fury 跨语言序列化二进制格式 (xlang) 详解

本文档旨在深入、详细地解释 Fury 的跨语言（xlang）二进制序列化协议。内容主要基于 `xlang_serialization_spec.md` 文档，并结合了对序列化系统通用原理的理解。在文档未明确之处，会进行合理的推测并加以说明。

### 1. 核心设计理念

Fury 的 xlang 序列化格式是一种**动态的、支持引用和多态**的二进制格式。与 Protobuf、FlatBuffers 等基于静态 Schema 的格式不同，Fury 可以在运行时处理未知的对象类型、循环引用和复杂的对象图。这带来了极大的灵活性，但其二进制格式也相应地更加复杂。

其核心目标是：

*   **跨语言互操作性**: 在 Java, Python, C++, Go, Rust, JavaScript 等语言之间高效地传递复杂对象。
*   **高性能**: 通过紧凑的二进制格式、优化的编码算法和减少的元数据开销来实现高吞吐量和低延迟。
*   **易用性**: 开发者无需手动编写序列化逻辑，框架会自动处理。

### 2. 整体二进制布局

一个完整的 Fury 序列化二进制流通常遵循以下结构：

```
| Fury 头部 (Header) | 引用元数据 (Ref Meta) | 类型元数据 (Type Meta) | 对象值数据 (Value Data) |
```

1.  **Fury 头部**: 包含了魔数、协议版本、语言、字节序等基本信息。
2.  **引用元数据**: 处理对象是否为 `null`，以及是否是重复引用的关键部分。这是支持对象图（Object Graph）序列化的核心。
3.  **类型元数据**: 描述了对象的具体类型信息。对于复杂对象（如 Struct），这部分可能包含完整的 Schema 信息。
4.  **对象值数据**: 对象的实际内容，根据其类型进行编码。

**字节序**: 除非特殊说明，所有数据默认使用**小端字节序 (Little Endian)**。

---

### 3. Fury 头部 (Header)

头部是每个序列化流的开始，结构如下：

```
|    2 字节   |     4 bits    |  1 bit |  1 bit |  1 bit |  1 bit |   1 字节   |      可选的 4 字节       |
+-------------+---------------+--------+--------+--------+--------+------------+--------------------------+
|  魔数 (Magic) |   保留位      |  OOB   |  xlang | endian |  null  |  语言      | 元数据起始偏移量 (可选)  |
```

*   **魔数 (Magic Number)**: `0x62d4`，用于快速识别这是一个 Fury 序列化流。
*   **Null 标志 (null flag)**: 如果整个对象为 `null`，此位置1，后续所有部分都将省略。
*   **字节序 (endian flag)**: `1` 代表小端，`0` 代表大端。
*   **xlang 标志 (xlang flag)**: `1` 代表当前是跨语言格式，`0` 代表是 Java 专用格式。
*   **OOB (Out-of-Band) 标志**: 用于内部带外传输，通常为 `0`。
*   **语言 (language)**: 序列化时使用的语言（如 Java, Python 等）。反序列化端可以利用此信息进行优化。
*   **元数据起始偏移量 (meta start offset)**: 这是一个可选的4字节无符号整数。当启用元数据共享模式时，它指向流末尾所有类型元数据的起始位置。

---

### 4. 引用元数据 (Reference Meta)

这是 Fury 实现对象图序列化（包括循环引用）的关键。对于任何一个可能被引用的对象，在序列化其值之前，都会先写入一个字节标志。

| 标志名称              | 字节值 | 描述                                                                 |
| --------------------- | ------ | -------------------------------------------------------------------- |
| `NULL_FLAG`           | `-3`   | 对象为 `null`。                                                      |
| `REF_FLAG`            | `-2`   | 对象是重复引用。后面会紧跟一个 VarInt 编码的引用 ID。                |
| `NOT_NULL_VALUE_FLAG` | `-1`   | 对象非 `null`，且**不**需要跟踪其引用（例如，基础类型或配置中禁用了引用的类型）。 |
| `REF_VALUE_FLAG`      | `0`    | 对象非 `null`，需要跟踪引用，并且这是它**第一次**被序列化。            |

**工作流程**:

1.  序列化器内部维护一个 `(对象 -> 引用ID)` 的映射表。
2.  当序列化一个对象时：
    *   如果是 `null`，写入 `-3`。
    *   如果不是 `null`，检查映射表：
        *   如果**已存在**，说明是重复引用。写入 `-2`，然后写入该对象的引用 ID。对象的值**不会**被再次序列化。
        *   如果**不存在**：
            *   如果该类型**需要**引用跟踪，写入 `0`，将对象和新的 ID 存入映射表，然后继续序列化其类型和值。
            *   如果该类型**不需要**引用跟踪，写入 `-1`，然后继续序列化其类型和值。

---

### 5. 类型元数据 (Type Meta)

在写入对象的值之前，必须先指明其类型。类型的表示方式取决于对象的种类和配置。

#### 5.1. 基础类型

对于 `int`, `string`, `list` 等 Fury 内置支持的类型，会直接使用一个预定义的类型 ID（一个字节）来表示。

#### 5.2. 自定义结构体 (Struct)

这是最复杂的部分，因为它涉及到**Schema 演进**。

*   **Schema 一致模式 (Schema-consistent)**:
    *   **前提**: 序列化和反序列化两端拥有完全一致的类结构（字段名、类型、顺序等）。
    *   **格式**: 类型的元数据就是一个简单的**类型哈希 (Type Hash)**，一个4字节的整数。这个哈希值根据类结构计算得出。反序列化端会比较接收到的哈希和本地代码中对应类的哈希，如果不匹配则会报错。
    *   **优点**: 元数据开销极小，性能高。
    *   **缺点**: 缺乏灵活性，任何一方的类结构变更都可能导致反序列化失败。

*   **Schema 演进模式 (Schema-evolution)**:
    *   **前提**: 允许两端的类结构不一致（例如，一端增加了字段，另一端删除了字段）。
    *   **格式**: 第一次序列化某个类型的对象时，会将其完整的**类型定义 (Type Def)** 写入二进制流。
        *   **Type Def 结构**:
            ```
            | 8字节全局头 | 元数据头 | 字段元数据... |
            ```
            *   **全局头**: 包含一个50位的**类型哈希**，压缩标志，以及整个元数据的大小。
            *   **元数据头**: 包含字段数量等信息。
            *   **字段元数据**: 循环写入每个字段的信息，包括**字段名**、**字段类型信息**、**字段头（包含可否为null、是否跟踪引用等标志）**。
    *   **工作机制**:
        1.  序列化器维护一个本次序列化中已写入的 `Type Def` 列表。
        2.  当第一次遇到一个需要演进的类型时，将其 `Type Def` 序列化，并记录其在列表中的索引（例如，索引为0）。然后在对象值前写入 `| unsigned varint: 0b11111111 | type def |`。
        3.  当再次遇到**相同类型**的对象时，只需写入 `| unsigned varint: written index << 1 |`（例如，`0 << 1`）。反序列化端看到这个格式，就知道使用之前已经解析过的 `Type Def`。
    *   **优点**: 极高的灵活性，支持前后向兼容。
    *   **缺点**: 元数据开销较大，首次序列化性能较低。

---

### 6. 对象值数据 (Value Data)

这部分是根据 `Type Meta` 确定的类型来写入对象的实际数据。

#### 6.1. 基础类型

*   **bool**: 1字节，`0` 或 `1`。
*   **int8, int16, int32, int64**: 固定长度，小端字节序。
*   **varint32, varint64**:
    *   **无符号 (Unsigned)**: 使用标准的 VarInt 编码，每字节的最高位(MSB)是标志位。
    *   **有符号 (Signed)**: 先使用 **ZigZag** 编码将有符号整数映射为无符号整数（` (v << 1) ^ (v >> 31) `），然后再进行 VarInt 编码。这使得绝对值小的负数也能用很少的字节表示。
*   **float32, float64**: 4字节或8字节，IEEE 754 标准，小端字节序。

#### 6.2. 字符串 (String)

```
| unsigned varint64: (size << 2) | 编码标志 | 字符串二进制数据 |
```

*   将字符串长度（`size`）左移两位，然后用最低两位作为**编码标志**（`00`=latin1, `01`=utf-16, `10`=utf-8）。
*   将这个合并后的 `uint64` 值用 VarInt 编码。
*   最后写入字符串本身的字节。
*   **语言差异**: Java 8/9+ 中，Fury 会自动检测 String 是 `latin1` 还是 `utf-16` 编码以优化性能。跨语言场景默认使用 `UTF-8`。

#### 6.3. 列表/数组 (List/Array)

```
| unsigned varint64: 长度 | 1 字节元素头 | 元素数据... |
```

*   **元素头 (elements header)**: 这是一个非常重要的优化。它是一个字节的位掩码，用于描述列表内元素的同质性。
    *   `0b0001`: 元素是否跟踪引用？
    *   `0b0010`: 元素中是否有 `null`？
    *   `0b0100`: 元素的实际类型是否与声明的泛型类型不同？
    *   `0b1000`: 元素之间类型是否不同（多态列表）？
*   **元素数据**: 根据 `元素头` 的信息，序列化可以被高度优化。例如，如果头信息表明所有元素都非 `null`、同类型且不跟踪引用，那么在序列化每个元素时，就不再需要写入任何引用或类型元数据，只需连续写入它们的值即可。

#### 6.4. Map

Map 的序列化相对复杂，采用**分块 (chunk by chunk)** 的方式。

```
| unsigned varint: 总键值对数量 | 块数据... | 块数据... |
```

*   **块数据 (chunk data)**:
    ```
    | 1字节 KV头 | 1字节 块大小(N) | N个Key | N个Value |
    ```
    *   **KV头**: 类似于 List 的元素头，但包含了对 Key 和 Value 的描述（是否跟踪引用、是否有null等）。
    *   **块大小**: 这个块里有多少个键值对（最多255）。
*   **为什么分块**: 这种设计是为了在迭代Map时进行优化。序列化器会基于第一个键值对预测整个块的 `KV头`。如果后续的键值对元信息不一致了，就结束当前块，用新的 `KV头` 开始下一个块。

#### 6.5. 结构体 (Struct)

结构体的值就是将其所有字段按照**特定顺序**依次序列化。

*   **字段顺序**: 字段不是按照代码中的定义顺序，而是遵循一个严格的排序规则：
    1.  原生类型字段 (按 `bool/int8/.../float64` 排序)。
    2.  可为 `null` 的原生类型字段。
    3.  其他各种引用类型字段 (`list`, `map`, `struct` 等)。
    4.  同类中按字段名的蛇形命名法 (`snake_case`) 字母序排序。
*   **字段值**: 每个字段的值会根据其类型和引用策略，递归地进行序列化（即可能包含它自己的引用元数据、类型元数据和值数据）。

---

### 7. 示例

#### 示例1: 简单对象

**Java Class**:
```java
class Person {
  int age;
  String name;
}
// person = new Person(30, "Tom");
```

**二进制流 (简化示意)**:

```
| Fury Header | Ref Meta (0) | Type Meta (Struct Hash/Def) | Value Data                               |
+-------------+--------------+-----------------------------+------------------------------------------+
| ...         | 0x00         | 0x... (Person的类型哈希)      | 30 (4字节) | String "Tom" 的二进制表示... |
```

*   **Ref Meta**: `0` (`REF_VALUE_FLAG`)，表示这是个新对象。
*   **Type Meta**: 假设是 Schema 一致模式，写入 `Person` 类的4字节哈希。
*   **Value Data**:
    *   先写 `age` (原生类型在前)，`0x1E000000` (30的小端表示)。
    *   再写 `name` (引用类型在后)。这会触发一次字符串序列化：
        *   `Ref Meta`: `-1` (`NOT_NULL_VALUE_FLAG`)，字符串通常不跟踪引用。
        *   `Type Meta`: `string` 类型的 ID。
        *   `Value Data`: `(3 << 2) | 2` -> `14` 的 VarInt 编码，然后是 "Tom" 的 UTF-8 字节。

#### 示例2: 复杂对象 (列表和引用)

**Java Class**:
```java
class Company {
  String name;
  List<Person> employees;
}
// p1 = new Person(30, "Tom");
// p2 = new Person(25, "Jerry");
// company = new Company("Google", Arrays.asList(p1, p2, p1)); // p1被引用了两次
```

**二进制流 (简化示意)**:

1.  **序列化 `Company` 对象**:
    *   `Ref Meta(0)`, `Type Meta(Company)`, `Value(name="Google", employees=List)`

2.  **序列化 `employees` 列表**:
    *   `Ref Meta(-1)`, `Type Meta(List)`, `Value(...)`
    *   **List Value**: `长度(3)`, `元素头(...)`, `元素1`, `元素2`, `元素3`

3.  **序列化 `元素1` (p1)**:
    *   `Ref Meta(0)`, `Type Meta(Person)`, `Value(age=30, name="Tom")`
    *   序列化器将 `p1` 存入引用表，ID为0。

4.  **序列化 `元素2` (p2)**:
    *   `Ref Meta(0)`, `Type Meta(Person)`, `Value(age=25, name="Jerry")`
    *   序列化器将 `p2` 存入引用表，ID为1。

5.  **序列化 `元素3` (p1)**:
    *   检查引用表，发现 `p1` 已存在。
    *   写入 `Ref Meta(-2)` (`REF_FLAG`)。
    *   写入 `p1` 的引用 ID `0` (VarInt编码)。
    *   **结束，不再写入 p1 的值。**

### 8. 总结与推测

**明确的**:

*   协议是动态的，通过元数据（引用、类型）来管理对象图。
*   `Ref Meta` 是处理 `null` 和循环引用的核心。
*   `Type Meta` 支持 Schema 一致和 Schema 演进两种模式。
*   对 `List`, `Map` 等集合类型有专门的头信息进行同质性优化。
*   字段序列化有严格的排序规则。

**不明确或推测的**:

*   **元数据压缩**: 文档提到了元数据可以被压缩，但没有详述压缩算法。推测可能使用 Zlib 或类似的通用压缩库。
*   **自定义序列化器 (ext type)**: 文档提到了 `ext` 类型，允许用户注册自定义序列化器。其二进制格式完全由用户定义，Fury 只负责调度。
*   **多语言实现的细微差异**: 虽然协议是统一的，但不同语言在实现时可能会有细微差异。例如，Go 中没有继承，其多态处理可能与 Java 不同；Rust 的所有权模型可能会影响其对引用跟踪的默认行为。开发者在使用时需注意对应语言的文档。

这份文档提供了对 Fury xlang 二进制协议的深度解析。通过这种设计，Fury 在灵活性和性能之间取得了很好的平衡，使其成为一个强大的跨语言序列化框架。
