## Fury 二进制协议详解

本文档旨在详细解释 Fury 的序列化和反序列化二进制协议。内容基于对 `cpp/fory/row` 和 `docs/guide` 文件夹中代码和文档的理解。部分内容在文档不明确时会进行合理的推测。

### 1. 核心概念：基于行的二进制格式 (Row-based Binary Format)

Fury 的核心序列化格式是一种基于行的、与 [Apache Arrow](https://arrow.apache.org/) 兼容的二进制格式。这种格式的主要设计目标是实现**零拷贝 (Zero-Copy)** 的读写操作，从而极大地提升性能，尤其是在大数据处理和跨语言（如 Java, Python, C++）交互的场景下。

**核心思想**:

*   **数据即对象 (Data is the object)**: 序列化后的二进制数据本身就包含了完整的结构信息和数据，读取时无需重新构建整个对象，可以直接访问其中的任何字段。
*   **Schema驱动**: 序列化和反序列化都依赖于一个`Schema`（模式），该`Schema`定义了数据结构，包括字段名、类型和顺序。
*   **定长与变长分离**:
    *   **定长类型 (Fixed-size types)**: 如 `int`, `double`, `boolean` 等，直接按值存储在行数据中。
    *   **变长类型 (Variable-size types)**: 如 `String`, `List`, `Map`, `Struct` (嵌套对象) 等，在行数据中只存储一个64位的**偏移量和大小 (offset and size)**，实际数据存储在行数据的末尾或其他地方。

### 2. Row (行) 的内存布局

一个序列化后的 `Row` 对象在内存中由以下几部分组成：

1.  **Null值位图 (Null Bitmap)**:
    *   这是一个紧凑的位掩码，用于标记每个字段是否为 `null`。
    *   每个字段占用1个bit。如果第 `i` 个bit为1，表示第 `i` 个字段为 `null`；如果为0，则表示非 `null`。
    *   位图的长度是固定的，取决于 `Schema` 中字段的数量，计算方式为 `((num_fields + 63) / 64) * 8` 字节。这确保了位图的长度是8字节的倍数。

2.  **定长值区域 (Fixed-size Value Region)**:
    *   紧跟在Null值位图之后。
    *   这个区域存储所有字段的值或引用（对于变长类型）。
    *   每个字段占用固定的8个字节（64位）。
        *   **对于定长类型**: 直接存储其值（例如 `int32`, `float`, `boolean` 会被扩展或填充到8字节进行存储）。
        *   **对于变长类型**: 存储一个64位的复合值，其中高32位是**相对偏移量 (relative offset)**，低32位是**大小 (size)**。这个偏移量指向变长数据区域中该字段实际数据的起始位置。

3.  **变长数据区域 (Variable-size Data Region)**:
    *   位于定长值区域之后。
    *   这里连续存储着所有变长字段（如 `String`, `Array`, `Map`, `Struct`）的实际内容。
    *   数据的排列顺序没有严格规定，通过定长区域中的偏移量来定位。

**图示**:

```
+--------------------------------+---------------------------------------------+--------------------------------------------+
|      Null Bitmap (1)           |         Fixed-size Value Region (2)         |       Variable-size Data Region (3)        |
| (e.g., 8 bytes for < 64 fields)| (num_fields * 8 bytes)                      | (variable size)                            |
+--------------------------------+---------------------------------------------+--------------------------------------------+
|                                |                                             |                                            |
| [bit0, bit1, ...]              | [field0_val/ref, field1_val/ref, ...]       | [string_data, array_data, struct_data, ...] |
|                                |                                             |                                            |
+--------------------------------+---------------------------------------------+--------------------------------------------+
```

**代码依据**:

*   `cpp/fory/row/row.h` 中的 `Row` 类定义了 `bitmap_width_bytes_`，`num_fields_`。
*   `GetOffset(int i)` 方法计算了定长值区域中每个字段的偏移量：`base_offset_ + bitmap_width_bytes_ + i * 8`。
*   `GetBinary`, `GetString`, `GetStruct`, `GetArray`, `GetMap` 等方法都通过读取一个64位的 `offsetAndSize` 来获取变长数据的实际位置和大小。

### 3. 详细数据类型编码

#### 3.1. 原生类型 (Primitive Types)

*   **Boolean**: 存储为1个字节 (`uint8_t`)，`0` 代表 `false`，非 `0` 代表 `true`。在8字节的字段槽中，其余7字节会被填充。
*   **Int8, Int16, Int32, Int64**: 直接以其二进制形式存储。较小的类型（如 `Int8`）会被填充到8字节。
*   **Float, Double**: 按照 IEEE 754 标准的二进制表示存储。`Float` 会被填充到8字节。

#### 3.2. 字符串 (String)

*   在 `Row` 的定长区域，存储一个64位的 `offsetAndSize`。
*   `offsetAndSize` 的高32位是字符串数据在**变长数据区域**的相对偏移量。
*   `offsetAndSize` 的低32位是字符串的字节长度。
*   字符串本身以 UTF-8 编码（这是普遍实践，虽然代码中未明确指定，但与Arrow兼容性要求如此）存储在变长数据区域。

#### 3.3. 数组/列表 (Array/List)

`ArrayData` 的结构比 `Row` 更复杂一些，它自身也包含头部和数据体。

*   **在 `Row` 中**: 数组字段同样在定长区域存储一个指向 `ArrayData` 的 `offsetAndSize`。
*   **`ArrayData` 内存布局**:
    1.  **元素数量 (Number of Elements)**: 8字节 (`int64_t`)，表示数组中有多少个元素。
    2.  **Null值位图 (Null Bitmap)**: 和 `Row` 类似，用于标记数组中每个元素是否为 `null`。长度为 `((num_elements + 63) / 64) * 8` 字节。
    3.  **元素数据区域 (Element Data Region)**:
        *   如果数组的元素是**定长类型**（如 `List<Integer>`），则所有元素的值会紧凑地排列在这里。每个元素的大小是固定的（例如 `Integer` 是4字节）。
        *   如果数组的元素是**变长类型**（如 `List<String>` 或 `List<Struct>`），则这里存储的是每个元素的 `offsetAndSize` 引用，指向 `ArrayData` 自己的变长数据区。

**图示 (`ArrayData`)**:

```
+-----------------------+--------------------------+--------------------------------+--------------------------------+
|  Num Elements (8B)    |   Null Bitmap (var)      |   Element Values/Refs (var)    |   Variable-size Data (var)     |
+-----------------------+--------------------------+--------------------------------+--------------------------------+
```

**代码依据**:

*   `cpp/fory/row/row.h` 中的 `ArrayData` 类。
*   `PointTo` 方法解析了 `num_elements_` 和 `element_offset_`。
*   `CalculateHeaderInBytes` 方法定义了头部的计算方式：`8 + ((num_elements + 63) / 64) * 8`。

#### 3.4. Map/字典

`MapData` 被实现为两个并列的 `ArrayData`：一个用于存储所有的键 (keys)，另一个用于存储所有的值 (values)。

*   **在 `Row` 中**: Map字段在定长区域存储一个指向 `MapData` 的 `offsetAndSize`。
*   **`MapData` 内存布局**:
    1.  **Key Array Size**: 8字节 (`uint64_t`)，表示紧随其后的 `Key Array` 的总字节大小。
    2.  **Key Array**: 一个完整的 `ArrayData` 结构，包含了所有的键。
    3.  **Value Array**: 另一个完整的 `ArrayData` 结构，包含了所有的值。值的顺序与键的顺序一一对应。

**图示 (`MapData`)**:

```
+--------------------------+--------------------------------+--------------------------------+
| Key Array Size (8B)      |      Key Array (ArrayData)     |     Value Array (ArrayData)    |
+--------------------------+--------------------------------+--------------------------------+
```

**代码依据**:

*   `cpp/fory/row/row.h` 中的 `MapData` 类。
*   `PointTo` 方法将一块内存分割给 `keys_` 和 `values_` 两个 `ArrayData` 实例。

#### 3.5. 结构体/嵌套对象 (Struct)

嵌套的 `Struct` 被当作一个子 `Row` 来处理。

*   **在父 `Row` 中**: `Struct` 字段在定长区域存储一个指向子 `Row` 的 `offsetAndSize`。
*   **子 `Row` 数据**: 子 `Row` 的完整二进制数据（包括它自己的Null位图、定长区和变长区）被存储在父 `Row` 的变长数据区域。
*   这种递归的结构使得可以表示任意复杂的嵌套对象。

### 4. 序列化与反序列化过程（推测）

#### 序列化 (e.g., `encoder.toRow(foo)`)

1.  **Schema分析**: 首先，根据对象的类定义（如 `Foo.class`）生成一个 `Schema`。
2.  **大小计算**:
    *   遍历对象的所有字段，计算出 `Row` 所需的总大小。这需要两轮遍历（two-pass）：
        *   第一轮：计算Null位图大小和定长区域大小。对于变长字段，先假设一个固定的引用大小（8字节）。
        *   第二轮：递归地序列化所有变长字段（String, List, Map, Struct），得到它们各自的实际二进制大小，并累加到总大小中。
3.  **内存分配**: 分配一块足够大的连续内存（`Buffer`）。
4.  **数据写入**:
    *   再次遍历对象，开始填充内存。
    *   **写入Null位图**: 检查每个字段是否为null，并设置相应的bit。
    *   **写入变长数据**: 从变长数据区的起始位置开始，依次写入每个变长字段的实际内容（如字符串的字节、数组的数据等）。同时记录下每个变长数据块的相对偏移量和大小。
    *   **写入定长区域**: 遍历所有字段：
        *   如果是定长类型，直接将其值写入对应的8字节槽位。
        *   如果是变长类型，将上一步记录的 `offsetAndSize` 写入对应的8字节槽位。

#### 反序列化/读取 (e.g., `encoder.fromRow(binaryRow)` or direct access)

Fury的强大之处在于反序列化可以是**惰性的 (lazy)** 和 **零拷贝的 (zero-copy)**。

*   **完全反序列化 (`fromRow`)**:
    1.  创建一个新的目标语言对象（如 Java POJO）。
    2.  创建一个 `Row` 对象，并让它指向包含二进制数据的 `Buffer`。
    3.  遍历 `Schema` 中的每个字段。
    4.  对于每个字段，调用 `Row` 对象的 `Get...` 方法（如 `GetInt32`, `GetString`, `GetArray`）。
    5.  这些 `Get` 方法会解析Null位图、计算偏移量，并从 `Buffer` 中读取或引用数据。
    6.  对于变长类型，会递归地创建子 `ArrayData`, `MapData` 或 `Row` 对象，并继续解析，最终将数据填充到新的POJO中。

*   **零拷贝直接访问 (e.g., `binaryRow.getArray(1)`)**:
    1.  不需要创建新的POJO。
    2.  直接创建一个 `Row` 对象，指向二进制 `Buffer`。
    3.  当调用 `binaryRow.getArray(1)` 时，Fury执行以下操作：
        *   检查字段1是否为null。
        *   读取字段1的 `offsetAndSize`。
        *   创建一个 `ArrayData` 对象，让它指向 `Buffer` 中由 `offsetAndSize` 指定的内存区域。
    4.  返回这个 `ArrayData` 对象。之后对这个 `ArrayData` 的所有访问（如 `array.getInt64(5)`）都是直接在原始 `Buffer` 上进行计算和读取，完全没有数据拷贝和对象重建的开销。

### 5. 总结与不确定性

**明确的**:

*   整体采用基于 `Schema` 的行存格式。
*   内存布局分为 Null位图、定长区、变长区。
*   定长类型值内联存储，变长类型通过 `offset+size` 引用。
*   `Array`, `Map`, `Struct` 都有明确的、递归的二进制结构。
*   设计核心是为了实现零拷贝读取。

**不明确或推测的**:

*   **字节序 (Endianness)**: 文档和代码没有明确指出字节序。但考虑到与Arrow的兼容性和跨平台特性，几乎可以肯定是**小端字节序 (Little-Endian)**，这是Arrow的标准。
*   **对齐 (Alignment)**: 数据结构似乎是按8字节对齐的，但没有明确的文档说明。这对于SIMD等优化至关重要。
*   **具体写入顺序**: 变长数据区域中各个字段数据的写入顺序似乎并不重要，因为它们是通过绝对偏移量访问的。但为了优化缓存，可能会按字段顺序写入。
*   **接口/继承类型的处理**: `row_format_guide.md` 提到了对接口和继承的支持。推测其实现方式可能是在序列化时，除了对象本身的数据外，还会额外存储一个**类型ID或者类名**。在反序列化时，根据这个ID来确定具体的实现类，然后再进行解析。这可能会在 `Row` 的头部或某个特殊字段中增加额外信息。

这份文档提供了对 Fury 二进制协议的深度解析。通过这种高效的二进制格式，Fury 能够在不同语言和系统之间实现高性能、低延迟的数据交换。
